<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Notice Translator (vSafe) – GitHub Pages</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #0b0f17; color: #e9eef7; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 20px; }
    .card {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 14px;
      margin: 12px 0;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      position: relative;
      z-index: 1;
    }
    h1 { font-size: 20px; margin: 0 0 10px; }
    h2 { font-size: 16px; margin: 0 0 10px; opacity: 0.95; }
    label { display: block; font-size: 12px; opacity: 0.85; margin: 10px 0 6px; }
    input, textarea, select, button {
      width: 100%;
      box-sizing: border-box;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.25);
      color: #e9eef7;
      padding: 10px 12px;
      font-size: 14px;
      outline: none;
    }
    textarea { min-height: 140px; resize: vertical; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
    .muted { font-size: 12px; opacity: 0.75; line-height: 1.4; }
    .pill {
      display: inline-block;
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.14);
      margin-right: 6px;
    }
    .btnRow { display: flex; gap: 10px; flex-wrap: wrap; }
    .btnRow button { width: auto; min-width: 190px; cursor: pointer; }
    button#runBtn {
      background: linear-gradient(135deg, rgba(112,233,255,0.25), rgba(255,112,200,0.22));
      border: 1px solid rgba(255,255,255,0.22);
      font-weight: 700;
      position: relative;
      z-index: 9999; /* 버튼이 덮이는 상황 방지 */
      pointer-events: auto; /* 혹시라도 상속/오염 방지 */
    }
    button:disabled { opacity: 0.55; cursor: not-allowed; }

    /* “버튼 위 덮는 레이어”를 잡기 위한 안전장치:
       - 흔히 overlay/backdrop 클래스가 pointer-events를 먹는 경우가 많아서 방어적으로 none 처리 */
    .overlay, .backdrop, .modal-backdrop, .cover, .glass {
      pointer-events: none !important;
    }

    pre {
      white-space: pre-wrap;
      word-break: break-word;
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 10px;
      margin: 10px 0 0;
      font-size: 12px;
      line-height: 1.35;
    }

    .ok { color: #9ff0b0; }
    .warn { color: #ffd37a; }
    .bad { color: #ff8a8a; }

    .tiny { font-size: 11px; opacity: 0.7; }
    a { color: #9bd1ff; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Notice Translator (vSafe) – GitHub Pages</h1>
      <div class="muted">
        <span class="pill">진단</span>
        버튼 클릭이 “안 먹는 느낌”이면 보통 <b>덮는 레이어(pointer-events)</b> 또는 <b>z-index</b> 문제입니다.
        이 페이지는 로드시 <code>elementFromPoint()</code>로 버튼 중앙을 자동 검사합니다.
      </div>
      <pre id="diagBox">Loading diagnostics...</pre>
      <div class="btnRow" style="margin-top:10px;">
        <button id="diagBtn" type="button">Debug: elementFromPoint 재검사</button>
        <button id="copyDiagBtn" type="button">진단 결과 복사</button>
      </div>
      <div class="tiny" style="margin-top:8px;">
        (요청하신 항목: <code>typeof window.__VSAFE_LOADED__</code>, <code>elementFromPoint()</code> 결과를 이 패널에 표시)
      </div>
    </div>

    <div class="card">
      <h2>1) 연결 설정</h2>
      <div class="row">
        <div>
          <label>Worker Translate Endpoint</label>
          <input id="endpoint" value="https://broad-shadow-26ac.kkwak2kg.workers.dev/translate" />
          <div class="tiny">POST로 호출합니다.</div>
        </div>
        <div>
          <label>X-Translate-Token (TRANSLATE_TOKEN)</label>
          <input id="xToken" placeholder="예: abc123..." />
          <div class="tiny">항상 헤더 <code>X-Translate-Token</code>로 전송</div>
        </div>
      </div>

      <div class="row3" style="margin-top:8px;">
        <div>
          <label>Authorization 모드</label>
          <select id="authMode">
            <option value="none">안 보냄 (NONE)</option>
            <option value="raw">Raw (그대로)</option>
            <option value="bearer">Bearer (Bearer &lt;token&gt;)</option>
          </select>
          <div class="tiny">Worker 구현에 따라 raw/bearer가 갈립니다.</div>
        </div>
        <div style="grid-column: span 2;">
          <label>Worker Shared Token (WORKER_SHARED_TOKEN)</label>
          <input id="sharedToken" placeholder="필요할 때만. 401이면 raw/bearer를 바꿔보세요." />
          <div class="tiny">모드가 NONE이면 이 값은 전송되지 않습니다.</div>
        </div>
      </div>

      <div class="btnRow" style="margin-top:10px;">
        <button id="saveBtn" type="button">세션에 저장</button>
        <button id="clearBtn" type="button">세션 초기화</button>
      </div>
      <div class="tiny">저장은 <code>sessionStorage</code>만 사용 (새 탭/브라우저 재시작하면 초기화)</div>
    </div>

    <div class="card">
      <h2>2) 공지 입력</h2>
      <label>현상 입력(한국어 원문)</label>
      <textarea id="srcText" placeholder="예) 접속 불가 현상..."></textarea>

      <div class="row" style="margin-top:8px;">
        <div>
          <label>대상 언어</label>
          <select id="lang">
            <option value="EN">EN</option>
            <option value="JA">JA</option>
          </select>
        </div>
        <div>
          <label>요청 포맷</label>
          <select id="payloadMode">
            <option value="simple">simple: { text, targetLang }</option>
            <option value="openai">openai-ish: { input, target }</option>
          </select>
          <div class="tiny">Worker가 어떤 JSON을 기대하는지 모르면 두 모드로 번갈아 테스트하세요.</div>
        </div>
      </div>

      <div class="btnRow" style="margin-top:12px;">
        <button id="runBtn" type="button">번역/생성 (POST /translate)</button>
        <button id="runBtn2" type="button">클릭 테스트(alert)</button>
      </div>
      <div class="tiny">
        “클릭 테스트(alert)”도 안 뜨면 클릭이 덮이는 겁니다. (기존 페이지에 있던 방식과 동일)  
      </div>
    </div>

    <div class="card">
      <h2>3) 결과</h2>
      <label>Translated Text</label>
      <textarea id="outText" readonly placeholder="여기에 결과가 표시됩니다."></textarea>
    </div>

    <div class="card">
      <h2>4) 네트워크 로그</h2>
      <div class="btnRow">
        <button id="logClearBtn" type="button">로그 지우기</button>
      </div>
      <pre id="logBox">(아직 요청 없음)</pre>
    </div>
  </div>

<script>
(() => {
  // ---- Helpers ----
  const $ = (sel) => document.querySelector(sel);
  const now = () => new Date().toISOString();
  const safeTrim = (v) => (v ?? "").toString().trim();

  const logBox = $("#logBox");
  const diagBox = $("#diagBox");

  function appendLog(obj) {
    const prev = logBox.textContent === "(아직 요청 없음)" ? "" : logBox.textContent + "\n\n";
    logBox.textContent = prev + JSON.stringify(obj, null, 2);
  }

  // ---- Diagnostics: requested console checks, but shown in UI ----
  function elementFromPointReport() {
    const b = $("#runBtn");
    if (!b) return { error: "runBtn not found" };
    const r = b.getBoundingClientRect();
    const x = r.left + r.width / 2;
    const y = r.top + r.height / 2;
    const topEl = document.elementFromPoint(x, y);
    return {
      runBtnRect: { left: r.left, top: r.top, width: r.width, height: r.height },
      point: { x, y },
      topTag: topEl?.tagName ?? null,
      topId: topEl?.id ?? null,
      topClass: topEl?.className ?? null,
      isTopRunBtn: topEl === b,
      topPointerEvents: topEl ? getComputedStyle(topEl).pointerEvents : null,
      runBtnPointerEvents: getComputedStyle(b).pointerEvents,
      runBtnZ: getComputedStyle(b).zIndex
    };
  }

  function refreshDiagnostics() {
    const vSafe = typeof window.__VSAFE_LOADED__;
    const e = elementFromPointReport();
    const suspicion =
      e.error ? "bad"
      : (e.isTopRunBtn ? "ok" : "warn");

    const msg =
      suspicion === "ok" ? "✅ 버튼 중앙 top element = runBtn (클릭 덮임 가능성 낮음)"
      : suspicion === "warn" ? "⚠️ 버튼 중앙 위에 다른 엘리먼트가 잡힘 (덮는 레이어 가능성 큼)"
      : "❌ 진단 실패";

    diagBox.innerHTML =
      `${msg}\n\n` +
      `typeof window.__VSAFE_LOADED__ = ${vSafe}\n\n` +
      JSON.stringify(e, null, 2);

    // 시각적 힌트
    diagBox.className = suspicion === "ok" ? "ok"
                  : suspicion === "warn" ? "warn"
                  : "bad";
  }

  // ---- Session storage ----
  function loadSession() {
    const endpoint = sessionStorage.getItem("endpoint");
    const xToken = sessionStorage.getItem("xToken");
    const shared = sessionStorage.getItem("sharedToken");
    const authMode = sessionStorage.getItem("authMode");

    if (endpoint) $("#endpoint").value = endpoint;
    if (xToken) $("#xToken").value = xToken;
    if (shared) $("#sharedToken").value = shared;
    if (authMode) $("#authMode").value = authMode;
  }

  function saveSession() {
    sessionStorage.setItem("endpoint", safeTrim($("#endpoint").value));
    sessionStorage.setItem("xToken", safeTrim($("#xToken").value));
    sessionStorage.setItem("sharedToken", safeTrim($("#sharedToken").value));
    sessionStorage.setItem("authMode", $("#authMode").value);
    appendLog({ t: now(), type: "session_saved" });
  }

  function clearSession() {
    ["endpoint","xToken","sharedToken","authMode"].forEach(k => sessionStorage.removeItem(k));
    appendLog({ t: now(), type: "session_cleared" });
  }

  // ---- Request builder ----
  function buildHeaders() {
    const headers = { "Content-Type": "application/json" };

    const xToken = safeTrim($("#xToken").value);
    if (xToken) headers["X-Translate-Token"] = xToken;

    const mode = $("#authMode").value;
    const shared = safeTrim($("#sharedToken").value);

    if (mode !== "none" && shared) {
      headers["Authorization"] = (mode === "bearer") ? ("Bearer " + shared) : shared;
    }
    return headers;
  }

  function buildBody() {
    const text = $("#srcText").value ?? "";
    const targetLang = $("#lang").value;
    const mode = $("#payloadMode").value;

    if (mode === "openai") {
      return { input: text, target: targetLang };
    }
    return { text, targetLang };
  }

  async function runTranslate() {
    const endpoint = safeTrim($("#endpoint").value);
    const headers = buildHeaders();
    const body = buildBody();

    // Pre-flight diagnostics snapshot
    refreshDiagnostics();

    appendLog({
      t: now(),
      type: "request",
      endpoint,
      headersSent: Object.fromEntries(Object.entries(headers).map(([k,v]) => {
        // 토큰은 길이만 보여주고 싶으면 여기서 마스킹 가능. 지금은 그대로 출력.
        return [k, v];
      })),
      body
    });

    $("#runBtn").disabled = true;
    $("#runBtn").textContent = "요청 중...";

    try {
      const res = await fetch(endpoint, {
        method: "POST",
        mode: "cors",
        headers,
        body: JSON.stringify(body)
      });

      const text = await res.text();
      let parsed = null;
      try { parsed = JSON.parse(text); } catch (_) {}

      appendLog({
        t: now(),
        type: "response",
        status: res.status,
        ok: res.ok,
        // 서버에서 오는 인증 관련 힌트를 확인하기 위해 일부 헤더를 뽑습니다.
        respHeaders: {
          "content-type": res.headers.get("content-type"),
          "www-authenticate": res.headers.get("www-authenticate")
        },
        bodyText: text
      });

      // Output extraction heuristics
      if (parsed && typeof parsed === "object") {
        const candidate =
          parsed.translatedText ??
          parsed.translation ??
          parsed.text ??
          parsed.output ??
          parsed.result ??
          parsed.data ??
          null;

        $("#outText").value = (typeof candidate === "string")
          ? candidate
          : JSON.stringify(parsed, null, 2);
      } else {
        $("#outText").value = text;
      }

      if (res.status === 401) {
        $("#outText").value =
          "401 Unauthorized\n\n" +
          "✅ 체크리스트:\n" +
          "1) X-Translate-Token 값이 Worker의 TRANSLATE_TOKEN과 완전히 일치?\n" +
          "2) Authorization이 필요한 Worker인가?\n" +
          "3) Authorization 모드가 raw/bearer 중 Worker 구현과 일치?\n\n" +
          "아래 Network Log에서 headersSent를 확인하세요.\n\n" +
          $("#outText").value;
      }
    } catch (err) {
      appendLog({ t: now(), type: "fetch_error", message: String(err), err });
      $("#outText").value = "Fetch error: " + String(err);
    } finally {
      $("#runBtn").disabled = false;
      $("#runBtn").textContent = "번역/생성 (POST /translate)";
    }
  }

  // ---- Click debug: capture click + pointer-events overlay hints ----
  document.addEventListener("click", (ev) => {
    const path = (ev.composedPath ? ev.composedPath() : []);
    const top = path[0];
    // 너무 시끄러우면 끄세요. 지금은 '클릭 안 먹음' 디버깅 목적이라 남깁니다.
    appendLog({
      t: now(),
      type: "click_capture",
      target: {
        tag: top?.tagName ?? null,
        id: top?.id ?? null,
        class: top?.className ?? null
      }
    });
  }, true);

  // ---- Wire up ----
  window.addEventListener("DOMContentLoaded", () => {
    // mark loaded
    window.__VSAFE_LOADED__ = true;

    loadSession();
    refreshDiagnostics();

    $("#diagBtn").addEventListener("click", refreshDiagnostics);
    $("#copyDiagBtn").addEventListener("click", async () => {
      const txt = diagBox.textContent;
      try {
        await navigator.clipboard.writeText(txt);
        appendLog({ t: now(), type: "diag_copied" });
      } catch {
        appendLog({ t: now(), type: "diag_copy_failed" });
      }
    });

    $("#saveBtn").addEventListener("click", saveSession);
    $("#clearBtn").addEventListener("click", () => {
      clearSession();
      $("#endpoint").value = "https://broad-shadow-26ac.kkwak2kg.workers.dev/translate";
      $("#xToken").value = "";
      $("#sharedToken").value = "";
      $("#authMode").value = "none";
    });

    $("#logClearBtn").addEventListener("click", () => {
      logBox.textContent = "(아직 요청 없음)";
    });

    $("#runBtn2").addEventListener("click", () => {
      alert("✅ 클릭 이벤트가 정상적으로 버튼에 도달했습니다.");
    });

    $("#runBtn").addEventListener("click", (ev) => {
      // “클릭 자체가 안 나감” 디버깅을 위해 가장 확실하게 로그를 남김
      appendLog({ t: now(), type: "runBtn_clicked", note: "click handler reached" });
      runTranslate();
    });

    // 화면 리사이즈/스크롤 시에도 버튼 중앙 요소가 달라질 수 있어 재진단 편의 제공
    window.addEventListener("resize", () => setTimeout(refreshDiagnostics, 0));
    window.addEventListener("scroll", () => setTimeout(refreshDiagnostics, 0), { passive: true });
  });
})();
</script>
</body>
</html>
